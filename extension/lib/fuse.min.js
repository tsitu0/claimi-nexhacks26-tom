/**
 * Fuse.js v7.0.0 - Lightweight fuzzy-search library
 * https://fusejs.io/
 * 
 * Copyright (c) 2023 Kiro Risk
 * Licensed under the Apache License, Version 2.0
 * 
 * This is a minimal implementation for Claimly autofill.
 * For the full library, download from: https://cdn.jsdelivr.net/npm/fuse.js@7.0.0/dist/fuse.min.js
 */

(function(global,factory){typeof exports==="object"&&typeof module!=="undefined"?module.exports=factory():typeof define==="function"&&define.amd?define(factory):(global=typeof globalThis!=="undefined"?globalThis:global||self,global.Fuse=factory())})(this,function(){"use strict";function isArray(e){return!Array.isArray?Object.prototype.toString.call(e)==="[object Array]":Array.isArray(e)}const EXTENDED_SEARCH_UNAVAILABLE="Extended search is not available";const INCORRECT_INDEX_TYPE="Incorrect 'index' type";const LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY=e=>`Invalid value for key ${e}`;const PATTERN_LENGTH_TOO_LARGE=e=>`Pattern length exceeds max of ${e}.`;const MISSING_KEY_PROPERTY=e=>`Missing ${e} property in key`;const INVALID_KEY_WEIGHT_VALUE=e=>`Property 'weight' in key '${e}' must be a positive integer`;const hasOwn=Object.prototype.hasOwnProperty;class KeyStore{constructor(e){this._keys=[];this._keyMap={};let t=0;e.forEach(e=>{let n=createKey(e);this._keys.push(n);this._keyMap[n.id]=n;t+=n.weight});this._keys.forEach(e=>{e.weight/=t})}get(e){return this._keyMap[e]}keys(){return this._keys}toJSON(){return JSON.stringify(this._keys)}}function createKey(e){let t=null;let n=null;let r=null;let i=1;let s=null;if(typeof e==="string"||isArray(e)){r=e;t=createKeyPath(e);n=createKeyId(e)}else{if(!hasOwn.call(e,"name")){throw new Error(MISSING_KEY_PROPERTY("name"))}const o=e.name;r=o;if(hasOwn.call(e,"weight")){i=e.weight;if(i<=0){throw new Error(INVALID_KEY_WEIGHT_VALUE(o))}}t=createKeyPath(o);n=createKeyId(o);s=e.getFn}return{path:t,id:n,weight:i,src:r,getFn:s}}function createKeyPath(e){return isArray(e)?e:e.split(".")}function createKeyId(e){return isArray(e)?e.join("."):e}function get(e,t){let n=[];let r=false;const deepGet=(e,t,i)=>{if(e){if(!t[i]){if(e!==null&&e!==undefined){n.push(e.toString())}}else if(isArray(e)){for(let n=0,r=e.length;n<r;n+=1){deepGet(e[n],t,i)}}else{const s=t[i];const o=e[s];if(o!==null&&o!==undefined){if(i===t.length-1&&(typeof o==="string"||typeof o==="number"||typeof o==="boolean")){n.push(o.toString())}else{deepGet(o,t,i+1)}}}}};deepGet(e,isArray(t)?t:t.split("."),0);return n}const MatchOptions={includeMatches:false,findAllMatches:false,minMatchCharLength:1};const BasicOptions={isCaseSensitive:false,includeScore:false,keys:[],shouldSort:true,sortFn:(e,t)=>e.score===t.score?e.idx<t.idx?-1:1:e.score<t.score?-1:1};const FuzzyOptions={location:0,threshold:0.6,distance:100};const AdvancedOptions={useExtendedSearch:false,getFn:get,ignoreLocation:false,ignoreFieldNorm:false,fieldNormWeight:1};var Config={...BasicOptions,...MatchOptions,...FuzzyOptions,...AdvancedOptions};const SPACE=/[^ ]+/g;function norm(e=1,t=3){const n=new Map;const r=Math.pow(10,t);return{get(t){const i=t.match(SPACE);if(!i)return 1;const s=i.length;if(n.has(s)){return n.get(s)}const o=1/Math.pow(s,0.5*e);const a=parseFloat(Math.round(o*r)/r);n.set(s,a);return a},clear(){n.clear()}}}class FuseIndex{constructor({getFn:e=Config.getFn,fieldNormWeight:t=Config.fieldNormWeight}={}){this.norm=norm(t,3);this.getFn=e;this.isCreated=false;this.setIndexRecords()}setSources(e=[]){this.docs=e}setIndexRecords(e=[]){this.records=e}setKeys(e=[]){this.keys=e;this._keysMap={};e.forEach((e,t)=>{this._keysMap[e.id]=t})}create(){if(this.isCreated||!this.docs.length){return}this.isCreated=true;if(typeof this.docs[0]==="string"){this.docs.forEach((e,t)=>{this._addString(e,t)})}else{this.docs.forEach((e,t)=>{this._addObject(e,t)})}this.norm.clear()}add(e){const t=this.size();if(typeof e==="string"){this._addString(e,t)}else{this._addObject(e,t)}}removeAt(e){this.records.splice(e,1);for(let t=e,n=this.size();t<n;t+=1){this.records[t].i-=1}}getValueForItemAtKeyId(e,t){return e[this._keysMap[t]]}size(){return this.records.length}_addString(e,t){if(typeof e==="undefined"||e===null){return}let n={v:e,i:t,n:this.norm.get(e)};this.records.push(n)}_addObject(e,t){let n={i:t,$:{}};this.keys.forEach((t,r)=>{let i=t.getFn?t.getFn(e):this.getFn(e,t.path);if(typeof i==="undefined"){return}if(i===null){return}if(isArray(i)){let e=[];const t=[];for(let n=0,r=i.length;n<r;n+=1){const r=i[n];if(typeof r==="undefined"||r===null){continue}if(typeof r==="string"){const i=this.norm.get(r);t.push({v:r,i:n,n:i})}else{e.push({t:r.text,i:n,n:this.norm.get(r.text)})}}if(e.length){n.$[r]={v:e}}else{n.$[r]=t}}else if(typeof i==="string"){let e={v:i,n:this.norm.get(i)};n.$[r]=e}else{let e={v:i.text,n:this.norm.get(i.text)};n.$[r]=e}});this.records.push(n)}toJSON(){return{keys:this.keys,records:this.records}}}function createIndex(e,t,{getFn:n=Config.getFn,fieldNormWeight:r=Config.fieldNormWeight}={}){const i=new FuseIndex({getFn:n,fieldNormWeight:r});i.setKeys(e.map(createKey));i.setSources(t);i.create();return i}function parseIndex(e,{getFn:t=Config.getFn,fieldNormWeight:n=Config.fieldNormWeight}={}){const{keys:r,records:i}=e;const s=new FuseIndex({getFn:t,fieldNormWeight:n});s.setKeys(r);s.setIndexRecords(i);return s}function computeScore(e,{errors:t=0,currentLocation:n=0,expectedLocation:r=0,distance:i=Config.distance,ignoreLocation:s=Config.ignoreLocation}={}){const o=t/e.length;if(s){return o}const a=Math.abs(r-n);if(!i){return a?1:o}return o+a/i}function convertMaskToIndices(e=[],t=Config.minMatchCharLength){let n=[];let r=-1;let i=-1;let s=0;for(let o=e.length;s<o;s+=1){let o=e[s];if(o&&r===-1){r=s}else if(!o&&r!==-1){i=s-1;if(i-r+1>=t){n.push([r,i])}r=-1}}if(e[s-1]&&s-r>=t){n.push([r,s-1])}return n}const MAX_BITS=32;function search(e,t,n,{location:r=Config.location,distance:i=Config.distance,threshold:s=Config.threshold,findAllMatches:o=Config.findAllMatches,minMatchCharLength:a=Config.minMatchCharLength,includeMatches:c=Config.includeMatches,ignoreLocation:l=Config.ignoreLocation}={}){if(t.length>MAX_BITS){throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS))}const h=t.length;const u=e.length;const f=Math.max(0,Math.min(r,u));let d=s;let p=f;const g=a>1||c;const m=g?Array(u):[];let v;while((v=e.indexOf(t,p))>-1){let e=computeScore(t,{currentLocation:v,expectedLocation:f,distance:i,ignoreLocation:l});d=Math.min(e,d);p=v+h;if(g){let e=0;while(e<h){m[v+e]=1;e+=1}}}p=0;let y=-1;let x=[];let b=1;let w;const k=g?Array(u):[];for(let r=0;r<h;r+=1){let s=0;let a=0;while(s<u&&a<=u){const e=computeScore(t,{errors:r,currentLocation:f+a,expectedLocation:f,distance:i,ignoreLocation:l});if(e<=d){s=a;a+=1}else{a=0}if(s>0){w=1<<r-1;if((n[f+s-1]&w)!==0){b=computeScore(t,{errors:r,currentLocation:f+s-1,expectedLocation:f,distance:i,ignoreLocation:l});if(b<=d){d=b;y=f+s-1;if(g){let e=0;while(e<h){m[y-h+1+e]=1;e+=1}}if(y<=f){break}p=Math.max(1,2*f-y)}}s=0}else{break}}if(computeScore(t,{errors:r+1,currentLocation:f,expectedLocation:f,distance:i,ignoreLocation:l})>d){break}x[r]=n.slice()}const _=convertMaskToIndices(m,a);const S={isMatch:y>=0,score:Math.max(0.001,b)};if(c){S.indices=_}return S}function createPatternAlphabet(e){let t={};for(let n=0,r=e.length;n<r;n+=1){const i=e.charAt(n);t[i]=(t[i]||0)|1<<r-n-1}return t}class BitapSearch{constructor(e,{location:t=Config.location,threshold:n=Config.threshold,distance:r=Config.distance,includeMatches:i=Config.includeMatches,findAllMatches:s=Config.findAllMatches,minMatchCharLength:o=Config.minMatchCharLength,isCaseSensitive:a=Config.isCaseSensitive,ignoreLocation:c=Config.ignoreLocation}={}){this.options={location:t,threshold:n,distance:r,includeMatches:i,findAllMatches:s,minMatchCharLength:o,isCaseSensitive:a,ignoreLocation:c};this.pattern=a?e:e.toLowerCase();this.chunks=[];if(!this.pattern.length){return}const addChunk=(e,t)=>{this.chunks.push({pattern:e,alphabet:createPatternAlphabet(e),startIndex:t})};const l=this.pattern.length;if(l>MAX_BITS){let e=0;const t=l%MAX_BITS;const n=l-t;while(e<n){addChunk(this.pattern.substr(e,MAX_BITS),e);e+=MAX_BITS}if(t){const e=l-MAX_BITS;addChunk(this.pattern.substr(e),e)}}else{addChunk(this.pattern,0)}}searchIn(e){const{isCaseSensitive:t,includeMatches:n}=this.options;if(!t){e=e.toLowerCase()}if(this.pattern===e){let t={isMatch:true,score:0};if(n){t.indices=[[0,e.length-1]]}return t}const{location:r,distance:i,threshold:s,findAllMatches:o,minMatchCharLength:a,ignoreLocation:c}=this.options;let l=[];let h=0;let u=false;this.chunks.forEach(({pattern:t,alphabet:f,startIndex:d})=>{const{isMatch:p,score:g,indices:m}=search(e,t,f,{location:r+d,distance:i,threshold:s,findAllMatches:o,minMatchCharLength:a,includeMatches:n,ignoreLocation:c});if(p){u=true}h+=g;if(p&&m){l=[...l,...m]}});let f={isMatch:u,score:u?h/this.chunks.length:1};if(u&&n){f.indices=l}return f}}class BaseMatch{constructor(e){this.pattern=e}static isMultiMatch(e){return getMatch(e,this.multiRegex)}static isSingleMatch(e){return getMatch(e,this.singleRegex)}search(){}}function getMatch(e,t){const n=e.match(t);return n?n[1]:null}const registeredSearchers=[];function register(...e){registeredSearchers.push(...e)}function createSearcher(e,t){for(let n=0,r=registeredSearchers.length;n<r;n+=1){let r=registeredSearchers[n];if(r.condition(e,t)){return new r(e,t)}}return new BitapSearch(e,t)}const LogicalOperator={AND:"$and",OR:"$or"};const KeyType={PATH:"$path",PATTERN:"$val"};const isExpression=e=>!!(e[LogicalOperator.AND]||e[LogicalOperator.OR]);const isPath=e=>!!e[KeyType.PATH];const isLeaf=e=>!isArray(e)&&typeof e==="object"&&!isExpression(e);const convertToExplicit=e=>({[LogicalOperator.AND]:Object.keys(e).map(t=>({[t]:e[t]}))});function parse(e,t,{auto:n=true}={}){const next=e=>{let r=Object.keys(e);const i=isPath(e);if(!i&&r.length>1&&!isExpression(e)){return next(convertToExplicit(e))}if(isLeaf(e)){const r=i?e[KeyType.PATH]:r[0];const s=i?e[KeyType.PATTERN]:e[r];if(typeof s!=="string"){throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(r))}const o={keyId:createKeyId(r),pattern:s};if(n){o.searcher=createSearcher(s,t)}return o}let s={children:[],operator:r[0]};r.forEach(t=>{const r=e[t];if(isArray(r)){r.forEach(e=>{s.children.push(next(e))})}});return s};if(!isExpression(e)){e=convertToExplicit(e)}return next(e)}function createSearches(e,t,{ignoreFieldNorm:n=Config.ignoreFieldNorm}){const r=[];for(let i=0,s=e.length;i<s;i+=1){const s=e[i];r.push({item:s,idx:i,matches:[]});for(let e=0,i=t.length;e<i;e+=1){const i=t[e];const{score:o,matches:a}=searchItem(s,i,{ignoreFieldNorm:n});if(o){r[r.length-1].matches.push({score:o,key:i.keyId,value:i.pattern,idx:a&&a.length?a[0][0]:0,indices:a})}}}return r}function searchItem(e,t,{ignoreFieldNorm:n=Config.ignoreFieldNorm}){const{keyId:r,pattern:i,searcher:s}=t;const o=e.$[r];if(!o){return{score:0,matches:[]}}if(typeof o==="string"){const e=s.searchIn(o);if(!e.isMatch){return{score:0,matches:[]}}let t=e.score;if(!n){t*=1}return{score:t,matches:e.indices}}const a=[];let c=0;for(let e=0,r=o.length;e<r;e+=1){const r=o[e];const i=s.searchIn(r.v);if(!i.isMatch){continue}c+=1;let l=i.score;if(!n){l*=r.n}a.push({score:l,value:r.v,idx:r.i,indices:i.indices})}if(!a.length){return{score:0,matches:[]}}a.sort((e,t)=>e.score-t.score);const l=a[0];return{score:l.score/c,matches:l.indices}}function searchLogical(e,t,n,{includeMatches:r=Config.includeMatches,ignoreFieldNorm:i=Config.ignoreFieldNorm}){const evaluate=(e,t,s)=>{if(!e.children){const{keyId:n,searcher:o}=e;const a=t[n];if(!a){return[]}const c=[];if(typeof a==="string"){const e=o.searchIn(a);if(!e.isMatch){return[]}let t=e.score;if(!i){t*=1}if(r){c.push({score:t,key:n,value:a,idx:0,indices:e.indices})}return[{score:t,matches:c}]}for(let e=0,n=a.length;e<n;e+=1){const n=a[e];const l=o.searchIn(n.v);if(!l.isMatch){continue}let h=l.score;if(!i){h*=n.n}if(r){c.push({score:h,key:s,value:n.v,idx:n.i,indices:l.indices})}}return c.length?[{score:c[0].score,matches:c}]:[]}const o=[];for(let n=0,r=e.children.length;n<r;n+=1){const r=e.children[n];const i=evaluate(r,t,s);if(i.length){o.push(...i)}else if(e.operator===LogicalOperator.AND){return[]}}if(e.operator===LogicalOperator.OR&&!o.length){return[]}return o};const s=[];for(let r=0,i=n.records.length;r<i;r+=1){const i=n.records[r];const{$:o}=i;if(!o){continue}const a=evaluate(e,o,t);if(a.length){const e={idx:r,item:i,matches:[]};a.forEach(({matches:t})=>{e.matches.push(...t)});s.push(e)}}return s}function computeFinalScore(e,{ignoreFieldNorm:t=Config.ignoreFieldNorm}){e.forEach(e=>{let n=1;e.matches.forEach(({score:e,key:r})=>{n*=e});e.score=n})}function format(e,t,{includeMatches:n=Config.includeMatches,includeScore:r=Config.includeScore}={}){const i=[];if(n){i.push("matches")}if(r){i.push("score")}return e.map(e=>{const n={item:t[e.idx]};if(i.length){i.forEach(t=>{n[t]=e[t]})}return n})}class Fuse{constructor(e,t={},n){this.options={...Config,...t};if(this.options.useExtendedSearch){throw new Error(EXTENDED_SEARCH_UNAVAILABLE)}this._keyStore=new KeyStore(this.options.keys);this.setCollection(e,n)}setCollection(e,t){this._docs=e;if(t&&!(t instanceof FuseIndex)){throw new Error(INCORRECT_INDEX_TYPE)}this._myIndex=t||createIndex(this.options.keys,this._docs,{getFn:this.options.getFn,fieldNormWeight:this.options.fieldNormWeight})}add(e){if(typeof e!=="undefined"&&e!==null){this._docs.push(e);this._myIndex.add(e)}}remove(e=()=>false){const t=[];for(let n=0,r=this._docs.length;n<r;n+=1){const r=this._docs[n];if(e(r,n)){this.removeAt(n);t.push(r);n-=1}}return t}removeAt(e){this._docs.splice(e,1);this._myIndex.removeAt(e)}getIndex(){return this._myIndex}search(e,{limit:t=-1}={}){const{includeMatches:n,includeScore:r,shouldSort:i,sortFn:s,ignoreFieldNorm:o}=this.options;let a=typeof e==="string"?typeof this._docs[0]==="string"?this._search(e):this._searchObjectList(e):this._searchLogical(e);computeFinalScore(a,{ignoreFieldNorm:o});if(i){a.sort(s)}if(typeof t==="number"&&t>-1){a=a.slice(0,t)}return format(a,this._docs,{includeMatches:n,includeScore:r})}_search(e){const{includeMatches:t,ignoreFieldNorm:n}=this.options;const r=createSearcher(e,this.options);const{records:i}=this._myIndex;const s=[];for(let e=0,o=i.length;e<o;e+=1){const{v:o,n:a}=i[e];const{isMatch:c,score:l,indices:h}=r.searchIn(o);if(!c){continue}let u=l;if(!n){u*=a}const f={item:o,idx:e,matches:[{score:u,value:o}]};if(t){f.matches[0].indices=h}s.push(f)}return s}_searchObjectList(e){const{includeMatches:t}=this.options;const n=createSearcher(e,this.options);const{keys:r,records:i}=this._myIndex;const s=[];for(let e=0,o=i.length;e<o;e+=1){const{$:o,i:a}=i[e];if(!o){continue}const c=[];for(let e=0,i=r.length;e<i;e+=1){const i=r[e];const{v:s,n:a}=this._myIndex.getValueForItemAtKeyId(o,i.id);if(!s){continue}if(typeof s==="string"){const{isMatch:r,score:o,indices:l}=n.searchIn(s);if(!r){continue}c.push({score:o,key:i,value:s,idx:0,norm:a,indices:l})}else if(Array.isArray(s)){for(let e=0,r=s.length;e<r;e+=1){const{v:r,i:o,n:a}=s[e];const{isMatch:l,score:h,indices:u}=n.searchIn(r);if(!l){continue}c.push({score:h,key:i,value:r,idx:o,norm:a,indices:u})}}}if(!c.length){continue}const l={idx:a,item:i[e].v,matches:[]};for(let e=0,n=c.length;e<n;e+=1){const n=c[e];const{key:r,value:i,idx:s,norm:o,score:a,indices:h}=n;l.matches.push({score:a,key:r.src,value:i,idx:s,norm:o});if(t){l.matches[l.matches.length-1].indices=h}}s.push(l)}return s}_searchLogical(e){const t=parse(e,this.options);const{keys:n,records:r}=this._myIndex;return searchLogical(t,n,this._myIndex,this.options)}}Fuse.version="7.0.0";Fuse.createIndex=createIndex;Fuse.parseIndex=parseIndex;Fuse.config=Config;return Fuse});
